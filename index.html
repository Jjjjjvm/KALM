<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>محرر لغة كَلِمْ (بواجهة VS Code)</title>
    <!-- استخدام Tailwind CSS لتصميم عصري وجذاب -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- CodeMirror لإضافة محرر كود احترافي -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/vscode-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <style>
        body {
            font-family: 'Cairo', sans-serif;
        }
        .ide-container {
            height: 80vh; /* ارتفاع المحرر ليملأ الشاشة */
        }
        .CodeMirror {
            direction: rtl !important;
            text-align: right !important;
            height: 100% !important; /* تجعل المحرر يملأ المساحة المتاحة */
            font-size: 16px;
        }
        /* تغيير لون نصوص محرر CodeMirror إلى الرمادي */
        .CodeMirror-lines {
            color: #a0a0a0 !important; /* لون رمادي للنصوص */
        }
        .CodeMirror-gutters {
            background: #1e1e1e !important;
            border-left: 1px solid #333;
        }
        /* تصميم للنافذة المنبثقة (modal) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #252526;
            padding: 2rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid #333;
        }
        /* تصميم حقل الإدخال الجديد */
        .input-container {
            background-color: #1e1e1e;
            border-top: 1px solid #333;
            padding: 0.5rem;
            display: flex;
            align-items: center;
        }
        .input-container input {
            flex-grow: 1;
            background-color: #333;
            border: 1px solid #555;
            padding: 0.5rem 0.75rem;
            border-radius: 0.25rem;
            color: #fff;
            font-family: 'Cascadia Code', 'Fira Code', monospace; /* خط أحادي المسافة للمدخلات */
            font-size: 1rem;
            outline: none;
            text-align: right; /* محاذاة النص لليمين */
        }
        .input-container input::placeholder {
            color: #888;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div class="container mx-auto p-4 max-w-7xl">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-teal-400">لغة كَلِمْ</h1>
            <p class="text-gray-400 mt-1">بيئة تطوير متكاملة باللغة العربية</p>
        </header>

        <!-- حاوية بيئة التطوير الشبيهة بـ VS Code -->
        <div class="ide-container flex flex-row bg-[#1e1e1e] rounded-lg shadow-2xl border border-gray-700 overflow-hidden">
            
            <!-- المحتوى الرئيسي (المحرر والنتائج) -->
            <main class="flex flex-col flex-grow">
                <!-- شريط علوي للمحرر -->
                <div class="flex justify-between items-center bg-[#333333] p-2 border-b border-gray-700">
                    <span class="text-sm text-gray-300">ملف: main.klm</span>
                    <button id="runButton" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-5 rounded-md transition-all flex items-center gap-2">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.118v3.764a1 1 0 001.555.832l3.197-1.882a1 1 0 000-1.664l-3.197-1.882z" clip-rule="evenodd"></path></svg>
                        تشغيل
                    </button>
                </div>
                
                <!-- منطقة محرر الكود -->
                <div class="flex-grow relative">
                    <textarea id="codeInput"></textarea>
                </div>

                <!-- منطقة النتائج (الطرفية) -->
                <div class="h-1/3 flex flex-col border-t border-gray-700">
                    <div class="bg-[#333333] p-2 text-sm font-semibold">
                        <h3 class="text-gray-300">النتائج</h3>
                    </div>
                    <pre id="output" class="flex-grow bg-[#1e1e1e] p-4 whitespace-pre-wrap text-right font-mono text-sm overflow-y-auto"></pre>
                    <!-- حقل الإدخال الجديد يظهر هنا -->
                    <div id="inputContainer" class="input-container hidden">
                        <input type="text" id="promptInput" dir="rtl" placeholder="اكتب هنا...">
                    </div>
                </div>
            </main>

            <!-- الشريط الجانبي -->
            <aside class="w-16 bg-[#252526] border-r border-gray-700 flex flex-col items-center py-4 space-y-6">
                <!-- أيقونات وهمية للشريط الجانبي -->
                <div class="text-teal-400" title="الملفات">
                    <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path></svg>
                </div>
                <div class="text-gray-400 hover:text-teal-400 cursor-pointer" title="بحث">
                    <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                </div>
                <!-- أيقونة الإعدادات الحقيقية -->
                <div id="settingsIcon" class="text-gray-400 hover:text-teal-400 cursor-pointer" title="الإعدادات">
                    <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.096 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                </div>
            </aside>

        </div>
        
        <footer class="mt-8 text-center text-gray-500">
            <h3 class="font-bold text-xl mb-4 text-gray-400">دليل استخدام لغة كَلِمْ</h3>
            <div class="bg-[#252526] p-6 rounded-lg text-right space-y-2 max-w-4xl mx-auto border border-gray-700">
                <p><strong>- المتغيرات:</strong> <code>متغير س = 10</code></p>
                <p><strong>- الطباعة:</strong> <code>اطبع "أهلاً" + " " + "بالعالم"</code></p>
                <p><strong>- الشروط:</strong> <code>اذا س > 5 نفذ { اطبع "س أكبر من 5" }</code></p>
                <p><strong>- التكرار:</strong> <code>كرر 3 مرات { اطبع "مرحباً رقم " + ت }</code></p>
                <p class="text-teal-400 font-bold"><strong>- القوائم:</strong> <code>متغير فواكه = ["تفاح", "برتقال", "موز"]</code></p>
                <p class="text-teal-400 font-bold"><strong>- الوصول لعناصر القائمة:</strong> <code>اطبع فواكه[0]</code></p>
                <p class="text-blue-400 font-bold"><strong>- تعريف الدوال:</strong> <code>دالة جمع(أ, ب) { اطبع أ + ب }</code></p>
                <p class="text-blue-400 font-bold"><strong>- استدعاء الدوال:</strong> <code>جمع(5, 3)</code></p>
                <p class="text-purple-400 font-bold"><strong>- الإدخال:</strong> <code>متغير قيمة = ادخل("أدخل نصاً: ")</code></p>
                <p class="text-purple-400 font-bold"><strong>- الإدخال الشرطي:</strong> <code>متغير قيمة = ادخل("الرسالة_الأولى", "القيمة_المشغلة", "الرسالة_الثانية")</code></p>
                <p class="text-green-400 font-bold"><strong>- عشوائي_بين:</strong> <code>عشوائي_بين(0, 1)</code> (عدد عشري)</p>
                <p class="text-green-400 font-bold"><strong>- عشوائي_عدد_صحيح:</strong> <code>عشوائي_عدد_صحيح(1, 10)</code> (عدد صحيح)</p>
                <p class="text-yellow-400 font-bold"><strong>- التكرار الأبدي (بينما):</strong> <code>بينما شرط صحيح { ... }</code></p>
                <p class="text-orange-400 font-bold"><strong>- فصل (كدالة نصية):</strong> <code>نص.فصل("فاصل")</code> أو <code>نص.فصل()</code> (لتقسيم النص)</p>
            </div>
        </footer>

    </div>

    <!-- نافذة الإعدادات المنبثقة -->
    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-teal-400 mb-4 text-right">مصادر تعليمية</h2>
            <p class="text-gray-300 mb-6 text-right">استكشف بعض المفاهيم الأساسية في البرمجة ودليل لغة كَلِمْ.</p>
            
            <div class="space-y-4 text-right">
                <div>
                    <h4 class="text-lg font-semibold text-teal-300">مقدمة في البرمجة:</h4>
                    <ul class="list-disc list-inside text-gray-400 mr-4">
                        <li>المتغيرات وأنواع البيانات</li>
                        <li>الجمل الشرطية (اذا)</li>
                        <li>الحلقات التكرارية (كرر، بينما)</li>
                        <li>الدوال (دالة، فصل)</li>
                        <li>الإدخال (ادخل)</li>
                        <li>القيم العشوائية</li>
                    </ul>
                </div>
                <div>
                    <h4 class="text-lg font-semibold text-teal-300">دليل لغة كَلِمْ:</h4>
                    <ul class="list-disc list-inside text-gray-400 mr-4">
                        <li><p><strong>- المتغيرات:</strong> <code>متغير س = 10</code></p></li>
                        <li><p><strong>- الطباعة:</strong> <code>اطبع "أهلاً" + " " + "بالعالم"</code></p></li>
                        <li><p><strong>- الشروط:</strong> <code>اذا س > 5 نفذ { اطبع "س أكبر من 5" }</code></p></li>
                        <li><p class="text-yellow-400 font-bold"><strong>- التكرار الأبدي (بينما):</strong> <code>بينما شرط صحيح { ... }</code></p></li>
                        <li><p><strong>- القوائم:</strong> <code>متغير فواكه = ["تفاح", "برتقال", "موز"]</code></p></li>
                        <li><p><strong>- الوصول لعناصر القائمة:</strong> <code>اطبع فواكه[0]</code></p></li>
                        <li><p class="text-orange-400 font-bold"><strong>- فصل (كدالة نصية):</strong> <code>نص.فصل("فاصل")</code> أو <code>نص.فصل()</code> (لتقسيم النص)</p></li>
                        <li><p class="text-blue-400 font-bold"><strong>- تعريف الدوال:</strong> <code>دالة جمع(أ, ب) { اطبع أ + ب }</code></p></li>
                        <li><p class="text-blue-400 font-bold"><strong>- استدعاء الدوال:</strong> <code>جمع(5, 3)</code></p></li>
                        <li><p class="text-purple-400 font-bold"><strong>- الإدخال:</strong> <code>متغير قيمة = ادخل("أدخل نصاً: ")</code></p></li>
                        <li><p class="text-purple-400 font-bold"><strong>- الإدخال الشرطي:</strong> <code>متغير قيمة = ادخل("الرسالة_الأولى", "القيمة_المشغلة", "الرسالة_الثانية")</code></p></li>
                        <li><p class="text-green-400 font-bold"><strong>- عشوائي_بين:</strong> <code>عشوائي_بين(0, 1)</code> (عدد عشري)</p></li>
                        <li><p class="text-green-400 font-bold"><strong>- عشوائي_عدد_صحيح:</strong> <code>عشوائي_عدد_صحيح(1, 10)</code> (عدد صحيح)</p></li>
                    </ul>
                </div>
            </div>

            <button id="closeModal" class="mt-8 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-5 rounded-md transition-all absolute top-4 left-4">إغلاق</button>
        </div>
    </div>

    <script>
        // --- إعداد محرر الكود ---
        const editor = CodeMirror.fromTextArea(document.getElementById("codeInput"), {
            lineNumbers: true,
            mode: "javascript",
            theme: "vscode-dark",
            lineWrapping: true,
        });
        
        // إزالة الكود الافتراضي لجعل المحرر يبدأ فارغًا
        editor.setValue(``); 

        // إضافة ميزة الإكمال التلقائي
        editor.on('keypress', function(instance, event) {
            const ch = event.key;
            const pairs = {
                '"': '"',
                "'": "'",
                '(': ')',
                '[': ']',
                '{': '}'
            };

            // إذا كان الحرف المدخل هو أحد الأحرف التي نريد إكمالها
            if (pairs[ch]) {
                const cursor = instance.getCursor();
                const line = instance.getLine(cursor.line);
                const charAfter = line.charAt(cursor.ch);

                // إذا لم يكن هناك حرف إغلاق بالفعل بعد المؤشر، قم بالإكمال
                if (charAfter !== pairs[ch]) {
                    instance.replaceSelection(pairs[ch]); // أدخل الحرف المكمل
                    instance.setCursor(cursor.line, cursor.ch); // أعد المؤشر إلى المنتصف
                }
            }
        });

        // --- المراجع لعناصر الواجهة ---
        const runButton = document.getElementById('runButton');
        const outputDiv = document.getElementById('output');
        const settingsIcon = document.getElementById('settingsIcon');
        const settingsModal = document.getElementById('settingsModal');
        const closeModalButton = document.getElementById('closeModal');
        const inputContainer = document.getElementById('inputContainer');
        const promptInput = document.getElementById('promptInput');

        let resolveInputPromise; // لتخزين وظيفة حل الوعد الخاص بالإدخال

        // تشغيل الكود
        runButton.addEventListener('click', async () => { // جعل المستمع غير متزامن
            const code = editor.getValue();
            outputDiv.textContent = ''; // مسح النتائج السابقة
            const globalEnv = {};
            try {
                // استدعاء المترجم بشكل غير متزامن
                await interpret(code, globalEnv); 
            } catch (e) {
                outputDiv.textContent += `\n❌ خطأ: ${e.message}\n${e.stack ? e.stack.split('\n')[1] : ''}`;
            } finally {
                // التأكد من إخفاء حقل الإدخال بعد الانتهاء (حتى لو حدث خطأ)
                inputContainer.classList.add('hidden');
            }
        });

        // فتح نافذة الإعدادات
        settingsIcon.addEventListener('click', () => {
            settingsModal.classList.remove('hidden');
        });

        // إغلاق نافذة الإعدادات
        closeModalButton.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
        });

        // إغلاق النافذة بالنقر خارجها
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                settingsModal.classList.add('hidden');
            }
        });

        // معالج حدث لإدخال المستخدم
        promptInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // منع إضافة سطر جديد في حقل الإدخال
                const inputValue = promptInput.value;
                outputDiv.textContent += inputValue + '\n'; // طباعة المدخل في منطقة النتائج
                promptInput.value = ''; // مسح حقل الإدخال
                inputContainer.classList.add('hidden'); // إخفاء الحقل
                if (resolveInputPromise) {
                    resolveInputPromise(inputValue); // حل الوعد بالقيمة المدخلة
                    resolveInputPromise = null; // إعادة تعيين
                }
            }
        });

        // دالة مساعدة لتحليل وسائط الدوال (تقسيم النصوص بالفاصل مع الحفاظ على الأقواس وعلامات الاقتباس)
        function parseArguments(argsContent) {
            let args = [];
            let tempExpr = '';
            let parenBalance = 0;    // لـ ()
            let bracketBalance = 0;  // لـ []
            let braceBalance = 0;    // لـ {}
            let inString = false;    // لتحديد ما إذا كنا داخل سلسلة نصية
            let stringChar = '';     // لتخزين نوع علامة الاقتباس (", ')

            for (let k = 0; k < argsContent.length; k++) {
                const char = argsContent[k];

                if (char === '"' || char === "'") {
                    if (inString && char === stringChar) {
                        inString = false;
                        stringChar = '';
                    } else if (!inString) {
                        inString = true;
                        stringChar = char;
                    }
                    tempExpr += char;
                } else if (inString) { // إذا كنا داخل سلسلة نصية، أضف الحرف مباشرةً
                    tempExpr += char;
                } else if (char === '(') {
                    parenBalance++;
                    tempExpr += char;
                } else if (char === ')') {
                    parenBalance--;
                    tempExpr += char;
                } else if (char === '[') {
                    bracketBalance++;
                    tempExpr += char;
                } else if (char === ']') {
                    bracketBalance--;
                    tempExpr += char;
                } else if (char === '{') {
                    braceBalance++;
                    tempExpr += char;
                } else if (char === '}') {
                    braceBalance--;
                    tempExpr += char;
                } else if (char === ',' && parenBalance === 0 && bracketBalance === 0 && braceBalance === 0) {
                    // إذا وجدنا فاصلة وليست داخل أقواس أو علامات اقتباس، قم بإضافة التعبير
                    args.push(tempExpr.trim());
                    tempExpr = '';
                } else {
                    tempExpr += char;
                }
            }
            // إضافة التعبير الأخير بعد الانتهاء من التحليل
            if (tempExpr.trim() !== '') {
                args.push(tempExpr.trim());
            }
            return args;
        }


        // دالة المترجم الرئيسية (أصبحت غير متزامنة)
        async function interpret(code, env) {
            const lines = code.split('\n');
            let i = 0;
            while (i < lines.length) {
                const line = lines[i].trim();

                if (line.startsWith('//') || line === '') {
                    i++;
                    continue;
                }

                if (line.startsWith('اطبع')) {
                    const argsContent = line.substring(5).trim();
                    const parsedArgs = parseArguments(argsContent); // استخدام الدالة المساعدة
                    let evaluatedArgs = [];

                    for (const argExpr of parsedArgs) {
                        evaluatedArgs.push(await evaluate(argExpr, env)); // انتظار تقييم كل جزء
                    }
                    
                    outputDiv.textContent += evaluatedArgs.map(val => {
                        if (Array.isArray(val)) {
                            return `[${val.map(item => {
                                if (typeof item === 'string') {
                                    return `'${item}'`;
                                }
                                return item;
                            }).join(', ')}]`;
                        }
                        return val;
                    }).join(' ') + '\n';
                    i++;
                }
                else if (line.match(/^متغير\s+.*/i) || line.match(/^[a-zA-Z\u0600-\u06FF_][a-zA-Z0-9\u0600-\u06FF_]*\s*\[.*\]\s*=/i) || line.match(/^[a-zA-Z\u0600-\u06FF_][a-zA-Z0-9\u0600-\u06FF_]*\s*=/i)) {
                    let varName, expression;
                    let parts;

                    // Improved splitting for variable assignment
                    const eqIndex = line.indexOf('=');
                    if (eqIndex === -1) {
                        throw new Error(`خطأ في الصيغة: السطر ${i + 1} يتوقع علامة '=' لتعريف أو تعديل متغير. الكود هو: "${line}"`);
                    }
                    if (line.startsWith('متغير')) {
                        varName = line.substring(6, eqIndex).trim();
                        expression = line.substring(eqIndex + 1).trim();
                    } else {
                        varName = line.substring(0, eqIndex).trim();
                        expression = line.substring(eqIndex + 1).trim();
                    }
                    
                    if (!varName) {
                        throw new Error(`خطأ في الصيغة: السطر ${i + 1} اسم المتغير لا يمكن أن يكون فارغاً. الكود هو: "${line}"`);
                    }
                    if (!expression) {
                        throw new Error(`خطأ في الصيغة: السطر ${i + 1} التعبير بعد '=' لا يمكن أن يكون فارغاً. الكود هو: "${line}"`);
                    }


                    const listAccessMatch = varName.match(/(.*)\[(.*)\]/);
                    if (listAccessMatch) {
                        const listName = listAccessMatch[1].trim();
                        const index = await evaluate(listAccessMatch[2].trim(), env); // انتظار تقييم الفهرس
                        if (!env[listName] || !Array.isArray(env[listName])) throw new Error(`المتغير '${listName}' ليس قائمة.`);
                        if (typeof index !== 'number') throw new Error(`فهرس القائمة يجب أن يكون رقماً.`);
                        env[listName][index] = await evaluate(expression, env); // انتظار تقييم التعبير
                    } else {
                        env[varName] = await evaluate(expression, env); // انتظار تقييم التعبير
                    }
                    i++;
                }
                else if (line.startsWith('اذا')) {
                    const { condition, body, linesConsumed } = parseBlock(lines, i, 'اذا');
                    const conditionResult = await evaluate(condition, env); // انتظار تقييم الشرط
                    if (conditionResult) {
                        await interpret(body, env); // انتظار تنفيذ الكتلة
                    }
                    i += linesConsumed + 1;
                }
                else if (line.startsWith('كرر')) {
                    const { condition, body, linesConsumed } = parseBlock(lines, i, 'كرر');
                    const count = parseInt(await evaluate(condition.split(' ')[0], env), 10); // انتظار تقييم عدد التكرارات
                    if (isNaN(count)) throw new Error("قيمة التكرار يجب أن تكون رقماً صحيحاً.");
                    
                    for (let j = 0; j < count; j++) {
                        const loopEnv = { ...env, 'ت': j + 1 };
                        await interpret(body, loopEnv); // انتظار تنفيذ كل تكرار
                    }
                    i += linesConsumed + 1;
                }
                // إضافة دعم لحلقة بينما (while loop)
                else if (line.startsWith('بينما')) {
                    const { condition, body, linesConsumed } = parseBlock(lines, i, 'بينما');
                    while (await evaluate(condition, env)) { // تكرار طالما الشرط صحيح
                        await interpret(body, env);
                    }
                    i += linesConsumed + 1;
                }
                else if (line.startsWith('دالة')) {
                    const { name, params, body, linesConsumed } = parseFunctionDefinition(lines, i);
                    env[name] = { type: 'function', params, body, env };
                    i += linesConsumed + 1;
                }
                // التعامل مع استدعاءات الدوال
                else if (line.match(/^[a-zA-Z\u0600-\u06FF_][a-zA-Z0-9\u0600-\u06FF_]*\s*\(.*\)/)) {
                    await evaluate(line, env); // انتظار تنفيذ استدعاء الدالة
                    i++;
                }
                else {
                    throw new Error(`أمر غير معروف أو صيغة خاطئة في السطر ${i + 1}: "${line}"`);
                }
            }
        }
        
        function parseBlock(lines, startIndex, keyword) {
            let line = lines[startIndex];
            let condition = "";
            let regex;
            if (keyword === 'اذا') regex = /اذا\s+(.*?)\s+نفذ\s*\{/;
            else if (keyword === 'كرر') regex = /كرر\s+(.*?)\s+مرات\s*\{/;
            else if (keyword === 'بينما') regex = /بينما\s+(.*?)\s*\{/; // Regex for while loop
            
            const match = line.match(regex);
            if (!match) throw new Error(`صيغة '${keyword}' غير صحيحة.`);
            condition = match[1];

            let openBraces = (line.match(/\{/g) || []).length;
            let bodyLines = [];
            let i = startIndex;
            
            if (openBraces === 0) {
              i++;
              if(!lines[i] || !lines[i].trim().startsWith('{')) throw new Error("القوس '{' مفقود بعد تعريف الكتلة.");
              openBraces = 1;
            }

            i++;
            while (i < lines.length && openBraces > 0) {
                const currentLine = lines[i];
                openBraces += (currentLine.match(/\{/g) || []).length;
                openBraces -= (currentLine.match(/\}/g) || []).length;
                if (openBraces > 0) {
                    bodyLines.push(currentLine);
                }
                i++;
            }
            if (openBraces > 0) throw new Error("لم يتم إغلاق القوس '}' بشكل صحيح.");
            
            return {
                condition: condition.trim(),
                body: bodyLines.join('\n'),
                linesConsumed: i - startIndex - 1
            };
        }

        function parseFunctionDefinition(lines, startIndex) {
            const defLine = lines[startIndex];
            const match = defLine.match(/دالة\s+([a-zA-Z\u0600-\u06FF_][a-zA-Z0-9\u0600-\u06FF_]*)\s*\((.*?)\)\s*\{/);
            if (!match) throw new Error("صيغة تعريف الدالة غير صحيحة. استخدم: دالة اسم(معامل1, معامل2) { ... }");
            const name = match[1];
            const params = match[2].split(',').map(p => p.trim()).filter(p => p);
            
            let openBraces = (defLine.match(/\{/g) || []).length;
            let bodyLines = [];
            let i = startIndex;
            
            if (openBraces === 0) {
              i++;
              if(!lines[i] || !lines[i].trim().startsWith('{')) throw new Error("القوس '{' مفقود بعد تعريف الدالة.");
              openBraces = 1;
            }

            i++;
            while (i < lines.length && openBraces > 0) {
                const currentLine = lines[i];
                openBraces += (currentLine.match(/\{/g) || []).length;
                openBraces -= (currentLine.match(/\}/g) || []).length;
                if (openBraces > 0) {
                    bodyLines.push(currentLine);
                }
                i++;
            }
            if (openBraces > 0) throw new Error(`لم يتم إغلاق القوس '}' للدالة '${name}'.`);

            return { name, params, body: bodyLines.join('\n'), linesConsumed: i - startIndex - 1 };
        }

        // دالة تقييم التعبيرات (أصبحت غير متزامنة)
        async function evaluate(expression, env) {
            expression = expression.trim();

            // *** إضافة فحص محدد لرسالة الخطأ التي واجهتها سابقًا ***
            const malformedStringRegex = /^""(?:[^"]*")*\.فصل\(/;
            if (malformedStringRegex.test(expression)) {
                throw new Error(`خطأ في الصيغة: يبدو أن هناك علامات اقتباس إضافية حول التعبير الذي تحاول فصله.
                تأكد أن الصيغة هي: 'متغير = ادخل("الرسالة").فصل("الفاصل")'
                أو 'متغير = "النص".فصل("الفاصل")'
                وتجنب علامات الاقتباس المزدوجة الفارغة '""' في بداية التعبير.`);
            }
            // *************************************************

            // 1. Handle literals (strings, numbers) and simple variable access
            if (expression.startsWith('"') && expression.endsWith('"')) return expression.slice(1, -1);
            if (!isNaN(parseFloat(expression)) && isFinite(expression)) return Number(expression);
            if (env.hasOwnProperty(expression)) return env[expression];

            // 2. Handle List Literals (e.g., ["a", "b"])
            if (expression.startsWith('[') && expression.endsWith(']')) {
                const items = parseArguments(expression.slice(1, -1));
                return await Promise.all(items.map(item => evaluate(item.trim(), env)));
            }

            // 3. Handle Special Built-in Functions/Keywords
            if (expression.startsWith('ادخل(') && expression.endsWith(')')) {
                const argsContent = expression.substring(5, expression.length - 1).trim();
                const parsedArgs = parseArguments(argsContent);

                if (parsedArgs.length < 1 || parsedArgs.length > 3) { // Now accepts 1 to 3 arguments
                    throw new Error("دالة 'ادخل' تتوقع معامل واحد (رسالة مطالبة) أو ثلاثة معاملات (رسالة مطالبة, شرط, رسالة ثانية).");
                }

                const prompt1Expr = parsedArgs[0];
                const evaluatedPrompt1 = prompt1Expr ? await evaluate(prompt1Expr, env) : '';

                outputDiv.textContent += (evaluatedPrompt1 || '') + '\n';
                inputContainer.classList.add('hidden');
                promptInput.focus();

                const firstInput = await new Promise(resolve => {
                    inputContainer.classList.remove('hidden');
                    resolveInputPromise = resolve;
                });

                if (parsedArgs.length === 3) {
                    const triggerValueExpr = parsedArgs[1];
                    const prompt2Expr = parsedArgs[2];

                    const evaluatedTriggerValue = await evaluate(triggerValueExpr, env);

                    if (firstInput === evaluatedTriggerValue) {
                        const evaluatedPrompt2 = await evaluate(prompt2Expr, env);
                        outputDiv.textContent += (evaluatedPrompt2 || '') + '\n';
                        inputContainer.classList.add('hidden');
                        promptInput.focus();

                        const secondInput = await new Promise(resolve => {
                            inputContainer.classList.remove('hidden');
                            resolveInputPromise = resolve;
                        });
                        return secondInput; // Return the second input
                    }
                }
                return firstInput; // Return the first input if no condition met or not enough args
            }

            // Handle Random functions directly in evaluate
            if (expression.startsWith('عشوائي_بين(') && expression.endsWith(')')) {
                const args = parseArguments(expression.substring('عشوائي_بين('.length, expression.length - 1));
                if (args.length !== 2) throw new Error("صيغة دالة 'عشوائي_بين' غير صحيحة. استخدم: عشوائي_بين(الحد_الأدنى, الحد_الأقصى)");
                const min = parseFloat(await evaluate(args[0], env));
                const max = parseFloat(await evaluate(args[1], env));
                if (isNaN(min) || isNaN(max)) {
                    throw new Error("معاملات دالة 'عشوائي_بين' يجب أن تكون أرقاماً.");
                }
                return Math.random() * (max - min) + min;
            }

            if (expression.startsWith('عشوائي_عدد_صحيح(') && expression.endsWith(')')) {
                const args = parseArguments(expression.substring('عشوائي_عدد_صحيح('.length, expression.length - 1));
                if (args.length !== 2) throw new Error("صيغة دالة 'عشوائي_عدد_صحيح' غير صحيحة. استخدم: عشوائي_عدد_صحيح(الحد_الأدنى, الحد_الأقصى)");
                const min = parseInt(await evaluate(args[0], env), 10);
                const max = parseInt(await evaluate(args[1], env), 10);
                if (isNaN(min) || isNaN(max)) {
                    throw new Error("معاملات دالة 'عشوائي_عدد_صحيح' يجب أن تكون أرقاماً صحيحة.");
                }
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // 4. Handle Member Access (Dot Notation) - X.Y()
            const dotAccessMatch = expression.match(/^(.*?)\.([a-zA-Z\u0600-\u06FF_][a-zA-Z0-9\u0600-\u06FF_]*)\((.*)\)$/);
            if (dotAccessMatch) {
                const objectExpr = dotAccessMatch[1].trim(); // e.g., "ادخل(\"رسالة\")" or "متغير_نص"
                const methodName = dotAccessMatch[2]; // e.g., "فصل"
                const methodArgsString = dotAccessMatch[3]; // e.g., "\" \""

                const obj = await evaluate(objectExpr, env); // Evaluate the object first

                if (methodName === 'فصل') {
                    if (typeof obj !== 'string') {
                        throw new Error(`الدالة '.فصل()' يمكن استدعاؤها فقط على النصوص.`);
                    }
                    const args = methodArgsString ? parseArguments(methodArgsString) : [];

                    let result;
                    if (args.length === 0) { // No delimiter provided, split by whitespace
                        // Simulating Python's split() with no arguments:
                        // Splits by any whitespace and discards empty strings.
                        result = obj.trim().split(/\s+/).filter(s => s !== '');
                    } else if (args.length === 1) { // Delimiter provided
                        const delimiter = await evaluate(args[0], env);
                        if (typeof delimiter !== 'string') {
                            throw new Error(`الفاصل لدالة '.فصل()' يجب أن يكون نصاً.`);
                        }
                        result = obj.split(delimiter);
                    } else {
                        throw new Error(`دالة '.فصل()' تتوقع صفر أو معامل واحد (الفاصل).`);
                    }
                    return result;
                } else {
                    throw new Error(`الدالة '${methodName}' غير معرفة أو غير مدعومة كدالة نصية.`);
                }
            }


            // 5. Handle List Access - variable[index]
            const listAccessMatch = expression.match(/(.*)\[(.*)\]/);
            if (listAccessMatch) {
                const listNameExpr = listAccessMatch[1].trim();
                const indexExpr = listAccessMatch[2].trim();
                const list = await evaluate(listNameExpr, env);
                const index = await evaluate(indexExpr, env);

                if (!Array.isArray(list)) throw new Error(`المتغير '${listNameExpr}' ليس قائمة.`);
                if (typeof index !== 'number' || index < 0 || index >= list.length) throw new Error(`فهرس القائمة غير صالح.`);
                return list[index];
            }

            // 6. Handle User-defined Function Calls - دالة_اسم(arg1, arg2)
            const funcCallMatch = expression.match(/^([a-zA-Z\u0600-\u06FF_][a-zA-Z0-9\u0600-\u06FF_]*)\s*\((.*)\)$/);
            if (funcCallMatch) {
                const funcName = funcCallMatch[1];
                const argsString = funcCallMatch[2];
                const func = env[funcName];
                if (func && func.type === 'function') {
                    const args = argsString ? await Promise.all(parseArguments(argsString).map(arg => evaluate(arg.trim(), env))) : [];
                    if (args.length !== func.params.length) throw new Error(`الدالة '${funcName}' تتوقع ${func.params.length} معاملات، ولكن تم تمرير ${args.length}.`);
                    const funcEnv = { ...func.env };
                    func.params.forEach((param, index) => { funcEnv[param] = args[index]; });
                    await interpret(func.body, funcEnv);
                    return; // Functions don't return values in this language, they just execute
                } else {
                    throw new Error(`الدالة '${funcName}' غير معرفة.`);
                }
            }

            // 7. Handle Operators (+, -, *, /, ==, >, <)
            const operators = ['==', '>', '<', '+', '-', '*', '/'];
            for (const op of operators) {
                let lastOpIndex = expression.lastIndexOf(op);
                if (lastOpIndex > -1) {
                    // Make sure the operator is not inside a string literal or parentheses/brackets/braces
                    let balance = 0;
                    let inString = false;
                    let stringChar = '';
                    let validOperator = false;
                    for (let k = 0; k < expression.length; k++) {
                        const char = expression[k];
                        if (char === '"' || char === "'") {
                            if (inString && char === stringChar) {
                                inString = false;
                                stringChar = '';
                            } else if (!inString) {
                                inString = true;
                                stringChar = char;
                            }
                        } else if (!inString) {
                            if (char === '(' || char === '[' || char === '{') balance++;
                            else if (char === ')' || char === ']' || char === '}') balance--;
                        }
                        if (k === lastOpIndex && !inString && balance === 0) {
                            validOperator = true;
                            break;
                        }
                    }

                    if (validOperator) {
                        const leftExpr = expression.substring(0, lastOpIndex).trim();
                        const rightExpr = expression.substring(lastOpIndex + op.length).trim();

                        const left = await evaluate(leftExpr, env);
                        const right = await evaluate(rightExpr, env);

                        switch (op) {
                            case '+': return typeof left === 'number' && typeof right === 'number' ? left + right : String(left) + String(right);
                            case '-': return left - right;
                            case '*': return left * right;
                            case '/': return left / right;
                            case '>': return left > right;
                            case '<': return left < right;
                            case '==': return left == right;
                        }
                    }
                }
            }

            throw new Error(`تعبير غير صالح أو متغير غير معرّف: "${expression}"`);
        }
    </script>
</body>
</html>
